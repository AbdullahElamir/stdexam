/**
 * Module dependencies.
 */

var debug = require('debug')('express:router:route');
<<<<<<< HEAD
=======
var Layer = require('./layer');
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
var methods = require('methods');
var utils = require('../utils');

/**
 * Expose `Route`.
 */

module.exports = Route;

/**
 * Initialize `Route` with the given `path`,
 *
 * @param {String} path
 * @api private
 */

function Route(path) {
  debug('new %s', path);
  this.path = path;
<<<<<<< HEAD
  this.stack = undefined;
=======
  this.stack = [];
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943

  // route handlers for various http methods
  this.methods = {};
}

/**
<<<<<<< HEAD
=======
 * @api private
 */

Route.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }

  method = method.toLowerCase();

  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

  return Boolean(this.methods[method]);
};

/**
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
 * @return {Array} supported HTTP methods
 * @api private
 */

<<<<<<< HEAD
Route.prototype._options = function(){
  return Object.keys(this.methods).map(function(method) {
    return method.toUpperCase();
  });
=======
Route.prototype._options = function _options() {
  var methods = Object.keys(this.methods);

  // append automatic head
  if (this.methods.get && !this.methods.head) {
    methods.push('head');
  }

  for (var i = 0; i < methods.length; i++) {
    // make upper case
    methods[i] = methods[i].toUpperCase();
  }

  return methods;
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
};

/**
 * dispatch req, res into this route
 *
 * @api private
 */

Route.prototype.dispatch = function(req, res, done){
<<<<<<< HEAD
  var self = this;
  var method = req.method.toLowerCase();

=======
  var idx = 0;
  var stack = this.stack;
  if (stack.length === 0) {
    return done();
  }

  var method = req.method.toLowerCase();
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

<<<<<<< HEAD
  req.route = self;

  // single middleware route case
  if (typeof this.stack === 'function') {
    this.stack(req, res, done);
    return;
  }

  var stack = self.stack;
  if (!stack) {
    return done();
  }

  var idx = 0;
  (function next_layer(err) {
=======
  req.route = this;

  next();

  function next(err) {
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
    if (err && err === 'route') {
      return done();
    }

    var layer = stack[idx++];
    if (!layer) {
      return done(err);
    }

    if (layer.method && layer.method !== method) {
<<<<<<< HEAD
      return next_layer(err);
    }

    var arity = layer.handle.length;
    if (err) {
      if (arity < 4) {
        return next_layer(err);
      }

      try {
        layer.handle(err, req, res, next_layer);
      } catch (err) {
        next_layer(err);
      }
      return;
    }

    if (arity > 3) {
      return next_layer();
    }

    try {
      layer.handle(req, res, next_layer);
    } catch (err) {
      next_layer(err);
    }
  })();
=======
      return next(err);
    }

    if (err) {
      layer.handle_error(err, req, res, next);
    } else {
      layer.handle_request(req, res, next);
    }
  }
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
};

/**
 * Add a handler for all HTTP verbs to this route.
 *
 * Behaves just like middleware and can respond or call `next`
 * to continue processing.
 *
 * You can use multiple `.all` call to add multiple handlers.
 *
 *   function check_something(req, res, next){
 *     next();
 *   };
 *
 *   function validate_user(req, res, next){
 *     next();
 *   };
 *
 *   route
 *   .all(validate_user)
 *   .all(check_something)
 *   .get(function(req, res, next){
 *     res.send('hello world');
 *   });
 *
 * @param {function} handler
 * @return {Route} for chaining
 * @api public
 */

Route.prototype.all = function(){
<<<<<<< HEAD
  var self = this;
=======
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
  var callbacks = utils.flatten([].slice.call(arguments));
  callbacks.forEach(function(fn) {
    if (typeof fn !== 'function') {
      var type = {}.toString.call(fn);
      var msg = 'Route.all() requires callback functions but got a ' + type;
      throw new Error(msg);
    }

<<<<<<< HEAD
    if (!self.stack) {
      self.stack = fn;
    }
    else if (typeof self.stack === 'function') {
      self.stack = [{ handle: self.stack }, { handle: fn }];
    }
    else {
      self.stack.push({ handle: fn });
    }
  });

  return self;
=======
    var layer = Layer('/', {}, fn);
    layer.method = undefined;

    this.methods._all = true;
    this.stack.push(layer);
  }, this);

  return this;
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
};

methods.forEach(function(method){
  Route.prototype[method] = function(){
<<<<<<< HEAD
    var self = this;
=======
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
    var callbacks = utils.flatten([].slice.call(arguments));

    callbacks.forEach(function(fn) {
      if (typeof fn !== 'function') {
        var type = {}.toString.call(fn);
        var msg = 'Route.' + method + '() requires callback functions but got a ' + type;
        throw new Error(msg);
      }

<<<<<<< HEAD
      debug('%s %s', method, self.path);

      if (!self.methods[method]) {
        self.methods[method] = true;
      }

      if (!self.stack) {
        self.stack = [];
      }
      else if (typeof self.stack === 'function') {
        self.stack = [{ handle: self.stack }];
      }

      self.stack.push({ method: method, handle: fn });
    });
    return self;
=======
      debug('%s %s', method, this.path);

      var layer = Layer('/', {}, fn);
      layer.method = method;

      this.methods[method] = true;
      this.stack.push(layer);
    }, this);
    return this;
>>>>>>> 6233b46d276f7d7bbeb7e779449ccc0594ea1943
  };
});
